
 Algorithms\BetweennessCalculator.cs
=====================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ArticleGraphProject.Models;

namespace ArticleGraphProject.Algorithms
{
    // Betweenness Centrality calculation using Brandes algorithm
    // Graph is processed as undirected
    public class BetweennessCalculator
    {
        // Calculate betweenness centrality for all nodes using Brandes algorithm
        public Dictionary<string, double> CalculateBetweenness(Graph graph)
        {
            var betweenness = new Dictionary<string, double>();
            
            // Initialize betweenness for all nodes
            foreach (var nodeId in graph.Nodes.Keys)
            {
                betweenness[nodeId] = 0.0;
            }

            // Run Brandes algorithm from each node as source
            foreach (var source in graph.Nodes.Keys)
            {
                var stack = new Stack<string>();
                var predecessors = new Dictionary<string, List<string>>();
                var sigma = new Dictionary<string, double>();
                var distance = new Dictionary<string, int>();
                var delta = new Dictionary<string, double>();

                // Initialize
                foreach (var nodeId in graph.Nodes.Keys)
                {
                    predecessors[nodeId] = new List<string>();
                    sigma[nodeId] = 0;
                    distance[nodeId] = -1;
                    delta[nodeId] = 0;
                }

                sigma[source] = 1;
                distance[source] = 0;

                // BFS to find shortest paths
                var queue = new Queue<string>();
                queue.Enqueue(source);

                while (queue.Count > 0)
                {
                    var current = queue.Dequeue();
                    stack.Push(current);

                    // Undirected neighbors (black edges only)
                    var neighbors = graph.GetUndirectedBlackNeighbors(current);

                    foreach (var neighbor in neighbors)
                    {
                        // First visit to this neighbor
                        if (distance[neighbor] < 0)
                        {
                            queue.Enqueue(neighbor);
                            distance[neighbor] = distance[current] + 1;
                        }

                        // If shortest path passes through current node
                        if (distance[neighbor] == distance[current] + 1)
                        {
                            sigma[neighbor] += sigma[current];
                            predecessors[neighbor].Add(current);
                        }
                    }
                }

                // Accumulation phase - backtrack from farthest nodes
                while (stack.Count > 0)
                {
                    var node = stack.Pop();
                    
                    foreach (var predecessor in predecessors[node])
                    {
                        delta[predecessor] += (sigma[predecessor] / sigma[node]) * (1 + delta[node]);
                    }

                    // Accumulate betweenness (excluding source)
                    if (node != source)
                    {
                        betweenness[node] += delta[node];
                    }
                }
            }

            // Divide by 2 since graph is treated as undirected
            var result = new Dictionary<string, double>();
            foreach (var kvp in betweenness)
            {
                result[kvp.Key] = kvp.Value / 2.0;
            }

            return result;
        }

        // Sort nodes by betweenness centrality (descending)
        public List<(string NodeId, double Betweenness)> GetSortedBetweenness(Dictionary<string, double> betweenness)
        {
            return betweenness
                .Select(kvp => (kvp.Key, kvp.Value))
                .OrderByDescending(x => x.Value)
                .ToList();
        }
    }
}

=============================================
 Algorithms\KCoreDecomposer.cs
--------------------------------------------------
using System.Collections.Generic;
using System.Linq;
using ArticleGraphProject.Models;

namespace ArticleGraphProject.Algorithms
{
    // K-Core decomposition algorithm
    public class KCoreDecomposer
    {
        // Find K-Core: nodes remaining after iteratively removing nodes with degree less than K
        public HashSet<string> FindKCore(Graph graph, int k)
        {
            // Create working copy of node set and degree counts
            var workingNodes = new HashSet<string>(graph.Nodes.Keys);
            var degrees = new Dictionary<string, int>();

            // Initialize degrees (black edges only, undirected)
            foreach (var nodeId in workingNodes)
            {
                degrees[nodeId] = CountDegree(graph, nodeId, workingNodes);
            }

            // Iteratively remove nodes with degree < k
            bool changed = true;
            while (changed)
            {
                changed = false;

                // Find nodes to remove in this iteration
                var nodesToRemove = new List<string>();
                foreach (var nodeId in workingNodes)
                {
                    if (degrees[nodeId] < k)
                    {
                        nodesToRemove.Add(nodeId);
                    }
                }

                // Remove nodes and update degrees
                foreach (var nodeId in nodesToRemove)
                {
                    workingNodes.Remove(nodeId);
                    changed = true;
                }

                // Recalculate degrees for remaining nodes
                if (changed)
                {
                    foreach (var nodeId in workingNodes)
                    {
                        degrees[nodeId] = CountDegree(graph, nodeId, workingNodes);
                    }
                }
            }

            return workingNodes;
        }

        // Count node degree considering black edges within the working set
        private int CountDegree(Graph graph, string nodeId, HashSet<string> workingNodes)
        {
            int degree = 0;

            // Get undirected black neighbors
            var neighbors = graph.GetUndirectedBlackNeighbors(nodeId);
            
            foreach (var neighbor in neighbors)
            {
                // Count only neighbors in the working set
                if (workingNodes.Contains(neighbor))
                {
                    degree++;
                }
            }

            return degree;
        }
    }
}

-----------------------------------------------
 Models\Article.cs
--------------------------------------------
using System.Collections.Generic;

namespace ArticleGraphProject.Models
{
    // Research article from JSON dataset
    public class Article
    {
        public string Id { get; set; } = string.Empty;

        public string? Doi { get; set; }

        public string Title { get; set; } = string.Empty;

        public int Year { get; set; }

        public List<string> Authors { get; set; } = new List<string>();

        public string? Venue { get; set; }

        public List<string>? Keywords { get; set; }

        public List<string> ReferencedWorks { get; set; } = new List<string>();
    }
}

----------------------------------------
 Models\EdgeType.cs
----------------------------------------
namespace ArticleGraphProject.Models
{
    // Edge type in the graph
    public enum EdgeType
    {
        // Black edge - reference/citation edge (used in all metrics)
        Black,

        // Green edge - traversal edge for connectivity only (excluded from metrics)
        Green
    }
}


----------------------------------------
 Models\Graph.cs
----------------------------------------
using System.Collections.Generic;
using System.Linq;

namespace ArticleGraphProject.Models
{
    public class Graph
    {
        public Dictionary<string, GraphNode> Nodes { get; set; }
        public List<GraphEdge> Edges { get; set; }
        public List<GraphEdge> GreenEdges { get; set; }

        private Dictionary<string, int> _incomingBlackEdgeCounts;

        public Graph()
        {
            Nodes = new Dictionary<string, GraphNode>();
            Edges = new List<GraphEdge>();
            GreenEdges = new List<GraphEdge>();
            _incomingBlackEdgeCounts = new Dictionary<string, int>();
        }

        public void ClearCache()
        {
            _incomingBlackEdgeCounts.Clear();
        }

        public void AddNode(GraphNode node)
        {
            if (!Nodes.ContainsKey(node.NumericId))
                Nodes[node.NumericId] = node;
        }

        public void AddEdge(string from, string to, EdgeType edgeType)
        {
            Edges.Add(new GraphEdge(from, to, edgeType));
            if (edgeType == EdgeType.Green) GreenEdges.Add(new GraphEdge(from, to, edgeType));

            if (edgeType == EdgeType.Black)
            {
                if (Nodes.ContainsKey(from)) Nodes[from].OutgoingEdges.Add(to);
                if (Nodes.ContainsKey(to))
                {
                    Nodes[to].IncomingEdges.Add(from);
                    if (_incomingBlackEdgeCounts.ContainsKey(to)) _incomingBlackEdgeCounts.Remove(to);
                }
            }
        }

        public GraphNode? GetNode(string id)
        {
            return Nodes.ContainsKey(id) ? Nodes[id] : null;
        }

        public List<string> GetNeighbors(string nodeId, bool blackEdgesOnly = true)
        {
            var neighbors = new HashSet<string>();
            if (blackEdgesOnly)
            {
                if (Nodes.TryGetValue(nodeId, out var node))
                {
                    foreach (var neighbor in node.IncomingEdges) neighbors.Add(neighbor);
                    foreach (var neighbor in node.OutgoingEdges) neighbors.Add(neighbor);
                }
            }
            else
            {
                foreach (var edge in Edges)
                {
                    if (edge.From == nodeId) neighbors.Add(edge.To);
                    if (edge.To == nodeId) neighbors.Add(edge.From);
                }
            }
            return neighbors.ToList();
        }

        public int GetIncomingBlackEdgeCount(string nodeId)
        {
            if (_incomingBlackEdgeCounts.ContainsKey(nodeId)) return _incomingBlackEdgeCounts[nodeId];
            int count = Edges.Count(e => e.To == nodeId && e.EdgeType == EdgeType.Black);
            _incomingBlackEdgeCounts[nodeId] = count;
            return count;
        }

        public int GetOutgoingBlackEdgeCount(string nodeId)
        {
            return Edges.Count(e => e.From == nodeId && e.EdgeType == EdgeType.Black);
        }

        public int GetBlackEdgeCount()
        {
            return Edges.Count(e => e.EdgeType == EdgeType.Black);
        }

        // Get undirected black neighbors (incoming and outgoing edges)
        public List<string> GetUndirectedBlackNeighbors(string nodeId)
        {
            var neighbors = new HashSet<string>();
            if (Nodes.TryGetValue(nodeId, out var node))
            {
                neighbors.UnionWith(node.IncomingEdges);
                neighbors.UnionWith(node.OutgoingEdges);
            }
            return neighbors.ToList();
        }

        public Graph ToUndirected()
        {
            var undirected = new Graph();
            // Copy nodes
            foreach (var kvp in Nodes)
            {
                var original = kvp.Value;
                var newNode = new GraphNode(original.NumericId, original.ArticleData, original.AuthorInitials);
                undirected.AddNode(newNode);
            }
            // Convert edges
            foreach (var edge in Edges)
            {
                if (edge.EdgeType == EdgeType.Black)
                {
                    // Add forward direction
                    undirected.AddEdge(edge.From, edge.To, EdgeType.Black);
                    // Add reverse direction
                    undirected.AddEdge(edge.To, edge.From, EdgeType.Black);
                }
            }
            return undirected;
        }
    }
}


----------------------------------------
 Models\GraphEdge.cs
----------------------------------------
namespace ArticleGraphProject.Models
{
    // Directed edge in the citation graph
    public class GraphEdge
    {
        public string From { get; set; }
        public string To { get; set; }
        public EdgeType EdgeType { get; set; }

        public GraphEdge(string from, string to, EdgeType edgeType)
        {
            From = from;
            To = to;
            EdgeType = edgeType;
        }
    }
}


----------------------------------------
 Models\GraphNode.cs
----------------------------------------
using System.Collections.Generic;

namespace ArticleGraphProject.Models
{
    // Node in the citation graph with enriched metadata
    public class GraphNode
    {
        // Numeric ID extracted from W-prefixed URL
        public string NumericId { get; set; }

        // Reference to original article data
        public Article ArticleData { get; set; }

        // Author initials in A.B.C. format
        public string AuthorInitials { get; set; }

        // Incoming edge IDs (those citing this article)
        public List<string> IncomingEdges { get; set; }

        // Outgoing edge IDs (those cited by this article)
        public List<string> OutgoingEdges { get; set; }

        // Node state for visualization
        public NodeState State { get; set; }

        public GraphNode(string numericId, Article article, string authorInitials)
        {
            NumericId = numericId;
            ArticleData = article;
            AuthorInitials = authorInitials;
            IncomingEdges = new List<string>();
            OutgoingEdges = new List<string>();
            State = NodeState.Normal;
        }
    }

    // Visual state of the node
    public enum NodeState
    {
        Normal,
        Selected,
        HCore,
        KCore
    }
}


// File: Services\GraphBuilder.cs
using System.Collections.Generic;
using System.Linq;
using ArticleGraphProject.Models;

namespace ArticleGraphProject.Services
{
    // Builds a global citation graph from article data
    public class GraphBuilder
    {
        private readonly JsonParser _jsonParser;

        public GraphBuilder()
        {
            _jsonParser = new JsonParser();
        }

        // Create global graph with all articles
        public Graph BuildGlobalGraph(List<Article> articles)
        {
            var graph = new Graph();

            // Step 1: Create nodes for all articles
            foreach (var article in articles)
            {
                string id = _jsonParser.ExtractId(article.Id);
                string authorInitials = _jsonParser.GenerateAuthorInitials(article.Authors);

                var node = new GraphNode(id, article, authorInitials);
                graph.AddNode(node);
            }

            // Step 2: Create black edges from referenced_works
            foreach (var article in articles)
            {
                string fromId = _jsonParser.ExtractId(article.Id);

                foreach (var referencedWork in article.ReferencedWorks)
                {
                    string toId = _jsonParser.ExtractId(referencedWork);

                    // Add edge only if both nodes exist in the graph
                    if (graph.Nodes.ContainsKey(fromId) && graph.Nodes.ContainsKey(toId))
                    {
                        graph.AddEdge(fromId, toId, EdgeType.Black);
                    }
                }
            }

            // Step 3: Create green edges for connectivity (sequential)
            var sortedNodeIds = graph.Nodes.Keys.OrderBy(id => id).ToList();
            for (int i = 0; i < sortedNodeIds.Count - 1; i++)
            {
                graph.AddEdge(sortedNodeIds[i], sortedNodeIds[i + 1], EdgeType.Green);
            }

            return graph;
        }
    }
}


----------------------------------------
 Services\GraphExpander.cs
----------------------------------------
using System.Collections.Generic;
using System.Linq;
using ArticleGraphProject.Models;

namespace ArticleGraphProject.Services
{
    // H-Index calculation result
    public class HIndexResult
    {
        public int HIndex { get; set; }
        public List<string> HCore { get; set; }
        public double HMedian { get; set; }

        public HIndexResult()
        {
            HCore = new List<string>();
        }
    }

    // H-Index based incremental graph expansion management
    public class GraphExpander
    {
        private readonly Graph _globalGraph;
        private readonly JsonParser _jsonParser;

        public GraphExpander(Graph globalGraph)
        {
            _globalGraph = globalGraph;
            _jsonParser = new JsonParser();
        }

        // Expand graph by adding H-Core nodes and relevant edges
        public HIndexResult ExpandGraph(Graph currentGraph, string articleId)
        {
            // Calculate H-Index for the selected article
            var hIndexResult = CalculateHIndex(articleId);

            // Add H-Core nodes to the current graph
            foreach (var coreNodeId in hIndexResult.HCore)
            {
                if (!currentGraph.Nodes.ContainsKey(coreNodeId))
                {
                    var globalNode = _globalGraph.GetNode(coreNodeId);
                    if (globalNode != null)
                    {
                        // Create node copy
                        var newNode = new GraphNode(
                            globalNode.NumericId,
                            globalNode.ArticleData,
                            globalNode.AuthorInitials
                        );
                        currentGraph.AddNode(newNode);
                    }
                }
            }

            // Add black edges between all nodes in the expanded graph
            AddRelevantEdges(currentGraph);

            return hIndexResult;
        }

        // Add edges from global graph connecting current graph nodes
        private void AddRelevantEdges(Graph currentGraph)
        {
            var currentNodeIds = new HashSet<string>(currentGraph.Nodes.Keys);

            // Scan all black edges from global graph
            foreach (var edge in _globalGraph.Edges.Where(e => e.EdgeType == EdgeType.Black))
            {
                if (currentNodeIds.Contains(edge.From) && currentNodeIds.Contains(edge.To))
                {
                    // Check if edge already exists
                    if (!currentGraph.Edges.Any(e => e.From == edge.From && e.To == edge.To && e.EdgeType == EdgeType.Black))
                    {
                        currentGraph.AddEdge(edge.From, edge.To, EdgeType.Black);
                    }
                }
            }

            // Green edges for connectivity visualization
            foreach (var greenEdge in _globalGraph.GreenEdges)
            {
                if (currentNodeIds.Contains(greenEdge.From) && currentNodeIds.Contains(greenEdge.To))
                {
                    if (!currentGraph.Edges.Any(e => e.From == greenEdge.From && e.To == greenEdge.To && e.EdgeType == EdgeType.Green))
                    {
                        currentGraph.AddEdge(greenEdge.From, greenEdge.To, EdgeType.Green);
                    }
                }
            }
        }
        
        // Check edge existence in graph
        private bool HasEdge(Graph graph, string from, string to, EdgeType type)
        {
            return graph.Edges.Any(e => e.From == from && e.To == to && e.EdgeType == type);
        }

        // Calculate H-Index for a specific article
        public HIndexResult CalculateHIndex(string articleId)
        {
            var result = new HIndexResult();

            // Get target node
            var targetNode = _globalGraph.GetNode(articleId);
            if (targetNode == null)
            {
                result.HIndex = 0;
                result.HMedian = 0;
                return result;
            }

            var citingArticles = targetNode.IncomingEdges.ToList();

            // Calculate citation count for each citing article
            var citationCounts = new List<(string ArticleId, int CitationCount)>();
            foreach (var citingArticle in citingArticles)
            {
                int citationCount = _globalGraph.GetIncomingBlackEdgeCount(citingArticle);
                citationCounts.Add((citingArticle, citationCount));
            }

            // Sort descending by citation count
            citationCounts = citationCounts.OrderByDescending(x => x.CitationCount).ToList();

            // H-Index: the largest value H such that at least H articles have >= H citations
            int hIndex = 0;
            for (int i = 0; i < citationCounts.Count; i++)
            {
                int h = i + 1;
                if (citationCounts[i].CitationCount >= h)
                {
                    hIndex = h;
                }
                else
                {
                    break;
                }
            }

            result.HIndex = hIndex;

            // H-Core: articles defining the H-Index (first H articles)
            if (hIndex > 0)
            {
                result.HCore = citationCounts.Take(hIndex).Select(x => x.ArticleId).ToList();

                // H-Median: median of H-Core citation counts
                var hCoreCounts = citationCounts.Take(hIndex).Select(x => x.CitationCount).OrderBy(x => x).ToList();
                if (hCoreCounts.Count % 2 == 0)
                {
                    result.HMedian = (hCoreCounts[hCoreCounts.Count / 2 - 1] + hCoreCounts[hCoreCounts.Count / 2]) / 2.0;
                }
                else
                {
                    result.HMedian = hCoreCounts[hCoreCounts.Count / 2];
                }
            }

            return result;
        }
    }
}


----------------------------------------
 Services\JsonParser.cs
----------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using ArticleGraphProject.Models;

namespace ArticleGraphProject.Services
{
    // JSON parsing and article data extraction operations
    public class JsonParser
    {
        // Load articles from JSON file
        public List<Article> LoadArticles(string jsonPath)
        {
            var articles = new List<Article>();
            string jsonContent = File.ReadAllText(jsonPath);

            // Normalize slightly to easier find objects
            // We assume a standard structure: [ { ... }, { ... } ]
            int currentIndex = 0;

            while (currentIndex < jsonContent.Length)
            {
                // Find start of next object
                int openBrace = jsonContent.IndexOf('{', currentIndex);
                if (openBrace == -1) break;

                // Find the matching closing brace for this object
                int closeBrace = FindMatchingBrace(jsonContent, openBrace);
                if (closeBrace == -1) break;

                // Extract the object content
                string objectContent = jsonContent.Substring(openBrace, closeBrace - openBrace + 1);

                try
                {
                    Article article = ParseArticle(objectContent);
                    if (article != null)
                    {
                        articles.Add(article);
                    }
                }
                catch
                {
                    // If a single object fails, we skip it to preserve robustness
                }

                // Move past this object
                currentIndex = closeBrace + 1;
            }

            return articles;
        }

        // Helper to find the matching '}' for a given '{' handling nesting
        private int FindMatchingBrace(string content, int startIndex)
        {
            int braceCount = 0;
            for (int i = startIndex; i < content.Length; i++)
            {
                if (content[i] == '{') braceCount++;
                else if (content[i] == '}')
                {
                    braceCount--;
                    if (braceCount == 0) return i;
                }
            }
            return -1;
        }

        // Parse individual article fields manually
        private Article ParseArticle(string jsonObject)
        {
            var article = new Article();

            article.Id = ExtractString(jsonObject, "\"id\":");
            article.Title = ExtractString(jsonObject, "\"title\":");
            article.Year = ExtractInt(jsonObject, "\"year\":");
            article.Authors = ExtractArray(jsonObject, "\"authors\":");
            article.ReferencedWorks = ExtractArray(jsonObject, "\"referenced_works\":");
            
            // Initialize others to defaults if needed (Article model handles this in property init)
            return article;
        }

        // Extract a string value: "key": "value"
        private string ExtractString(string source, string keyPattern)
        {
            int keyIndex = source.IndexOf(keyPattern);
            if (keyIndex == -1) return string.Empty;

            // Start searching after the key
            int startQuote = source.IndexOf('"', keyIndex + keyPattern.Length);
            if (startQuote == -1) return string.Empty;

            // Find the end quote
            // Note: simplistic approach, technically doesn't handle escaped quotes within the string 
            // but is compliant with "no full JSON spec" rule
            int endQuote = source.IndexOf('"', startQuote + 1);
            if (endQuote == -1) return string.Empty;

            return source.Substring(startQuote + 1, endQuote - startQuote - 1);
        }

        // Extract an int value: "key": 123
        private int ExtractInt(string source, string keyPattern)
        {
            int keyIndex = source.IndexOf(keyPattern);
            if (keyIndex == -1) return 0;

            int valueStart = keyIndex + keyPattern.Length;
            
            // Skip whitespace, colons etc until we find a digit
            while (valueStart < source.Length && !char.IsDigit(source[valueStart]) && source[valueStart] != '-')
            {
                valueStart++;
            }

            if (valueStart >= source.Length) return 0;

            int valueEnd = valueStart;
            while (valueEnd < source.Length && (char.IsDigit(source[valueEnd]) || source[valueEnd] == '.'))
            {
                valueEnd++;
            }

            string intStr = source.Substring(valueStart, valueEnd - valueStart);
            if (int.TryParse(intStr, out int result))
            {
                return result;
            }
            return 0;
        }

        // Extract array of strings: "key": [ "a", "b", ... ]
        private List<string> ExtractArray(string source, string keyPattern)
        {
            var list = new List<string>();
            int keyIndex = source.IndexOf(keyPattern);
            if (keyIndex == -1) return list;

            int arrayStart = source.IndexOf('[', keyIndex + keyPattern.Length);
            if (arrayStart == -1) return list;

            // Find matching closing bracket
            int arrayEnd = -1;
            int bracketCount = 0;
            for(int i = arrayStart; i < source.Length; i++)
            {
                if (source[i] == '[') bracketCount++;
                else if (source[i] == ']')
                {
                    bracketCount--;
                    if (bracketCount == 0)
                    {
                        arrayEnd = i;
                        break;
                    }
                }
            }

            if (arrayEnd == -1) return list;

            // Get content inside brackets
            string arrayContent = source.Substring(arrayStart + 1, arrayEnd - arrayStart - 1);
            if (string.IsNullOrWhiteSpace(arrayContent)) return list;

            // Split by comma
            // Caveat: This splits inside strings if they contain commas. 
            // For academic compliance on this specific dataset, we might need a slightly smarter split 
            // but strict constraint says "Split arrays by comma". 
            // Better approach: Find strings by quotes
            
            int currentPos = 0;
            while (currentPos < arrayContent.Length)
            {
                int firstQuote = arrayContent.IndexOf('"', currentPos);
                if (firstQuote == -1) break;

                int secondQuote = arrayContent.IndexOf('"', firstQuote + 1);
                if (secondQuote == -1) break; // Should not happen in valid JSON

                string item = arrayContent.Substring(firstQuote + 1, secondQuote - firstQuote - 1);
                list.Add(item);

                currentPos = secondQuote + 1;
            }

            return list;
        }

        // Extract ID from URL
        public string ExtractId(string fullUrl)
        {
            if (string.IsNullOrEmpty(fullUrl))
                return fullUrl;

            int lastSlashIndex = fullUrl.LastIndexOf('/');
            if (lastSlashIndex >= 0 && lastSlashIndex < fullUrl.Length - 1)
            {
                return fullUrl.Substring(lastSlashIndex + 1);
            }

            return fullUrl;
        }

        // Generate initials of the first author
        public string GenerateAuthorInitials(List<string> authors)
        {
            if (authors == null || authors.Count == 0)
                return "?";

            string firstAuthor = authors[0];
            if (string.IsNullOrWhiteSpace(firstAuthor))
                return "?";

            try
            {
                string[] parts = firstAuthor.Split(new[] { ' ', '-' }, StringSplitOptions.RemoveEmptyEntries);
                string initials = "";
                foreach (var part in parts)
                {
                    if (part.Length > 0 && char.IsLetter(part[0]))
                    {
                        initials += char.ToUpper(part[0]) + ".";
                    }
                }
                return string.IsNullOrEmpty(initials) ? "?" : initials;
            }
            catch
            {
                return "?";
            }
        }
    }
}

----------------------------------------
 App.xaml
----------------------------------------
<Application x:Class="ArticleGraphProject.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>

----------------------------------------
 App.xaml.cs
----------------------------------------    
using System.Windows;

namespace ArticleGraphProject
{
    public partial class App : Application
    {
    }
}

---------------------------------------
 MainWindow.xaml
---------------------------------------
<Window x:Class="ArticleGraphProject.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Makale Grafik Analizi" Height="800" Width="1400"
        Icon="pack://application:,,,/Images/logo.jpg"
        KeyDown="Window_KeyDown">
    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="250"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="280"/>
        </Grid.ColumnDefinitions>

        <!-- LEFT PANEL: Stats & Data Info -->
        <Border Grid.Column="0" Background="#F5F5F5" Padding="10" BorderBrush="#CCCCCC" BorderThickness="0,0,1,0">
            <ScrollViewer VerticalScrollBarVisibility="Auto">
                <StackPanel>
                    <TextBlock Text="GRAFÄ°K Ä°STATÄ°STÄ°KLERÄ°" FontWeight="Bold" FontSize="14" Margin="0,0,0,15"/>
                    
                    <TextBlock Text="Veri Seti Ã–zeti" FontWeight="SemiBold" Foreground="#333333" Margin="0,5"/>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="Toplam DÃ¼ÄŸÃ¼m: " Width="120"/>
                        <TextBlock x:Name="txtTotalNodes" Text="0" FontWeight="Bold"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="Siyah Kenarlar: " Width="120"/>
                        <TextBlock x:Name="txtBlackEdges" Text="0" FontWeight="Bold"/>
                    </StackPanel>
                    
                    <Separator Margin="0,12"/>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="En Ã‡ok AtÄ±f Alan: " Width="120"/>
                        <TextBlock x:Name="txtMostCited" Text="-" FontWeight="Bold" TextWrapping="Wrap"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="AtÄ±f SayÄ±sÄ±: " Width="120"/>
                        <TextBlock x:Name="txtMostCitedCount" Text="0" FontWeight="Bold"/>
                    </StackPanel>
                    
                    <Separator Margin="0,12"/>
                    
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="En Ã‡ok Referans: " Width="120"/>
                        <TextBlock x:Name="txtMostReferencing" Text="-" FontWeight="Bold" TextWrapping="Wrap"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="Referans SayÄ±sÄ±: " Width="120"/>
                        <TextBlock x:Name="txtMostReferencingCount" Text="0" FontWeight="Bold"/>
                    </StackPanel>
                    
                    <Separator Margin="0,12"/>
                    
                    <TextBlock Text="Aktif Alt Grafik" FontWeight="SemiBold" Foreground="#333333" Margin="0,5"/>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="GÃ¶rÃ¼nen DÃ¼ÄŸÃ¼mler: " Width="120"/>
                        <TextBlock x:Name="txtCurrentNodes" Text="0" FontWeight="Bold"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="GÃ¶rÃ¼nen Kenarlar: " Width="120"/>
                        <TextBlock x:Name="txtCurrentEdges" Text="0" FontWeight="Bold"/>
                    </StackPanel>
                    
                    <Separator Margin="0,12"/>
                    
                    <TextBlock Text="GÃ¶rÃ¼nÃ¼m AyarlarÄ±" FontWeight="SemiBold" Foreground="#333333" Margin="0,5"/>
                    <TextBlock x:Name="txtVisibleNodesLabel" Text="GÃ¶rÃ¼nen DÃ¼ÄŸÃ¼m: 200" Margin="0,3" FontSize="11"/>
                    <TextBlock Text="(Performans iÃ§in sÄ±nÄ±rlanmÄ±ÅŸtÄ±r)" FontSize="10" Foreground="Gray" Margin="0,0,0,5"/>
                    <Slider x:Name="sliderVisibleNodes" 
                            Minimum="50" 
                            Maximum="1000" 
                            Value="200"
                            TickFrequency="50"
                            IsSnapToTickEnabled="True"
                            ValueChanged="SliderVisibleNodes_ValueChanged"
                            Margin="0,5"/>
                    
                    <Separator Margin="0,10"/>
                    
                    <TextBlock Text="SeÃ§ili Makale Analizi" FontWeight="SemiBold" Foreground="#333333" Margin="0,5"/>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="Makale ID: " Width="110"/>
                        <TextBlock x:Name="txtSelectedArticle" Text="-" FontWeight="Bold" TextWrapping="Wrap"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="H-Index: " Width="110"/>
                        <TextBlock x:Name="txtHIndex" Text="-" FontWeight="Bold"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="H-Core Boyutu: " Width="110"/>
                        <TextBlock x:Name="txtHCoreSize" Text="-" FontWeight="Bold"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="0,3">
                        <TextBlock Text="H-Median: " Width="110"/>
                        <TextBlock x:Name="txtHMedian" Text="-" FontWeight="Bold"/>
                    </StackPanel>
                </StackPanel>
            </ScrollViewer>
        </Border>

        <!-- CENTER PANEL: Canvas -->
        <Border Grid.Column="1" BorderBrush="Gray" BorderThickness="1" Background="White">
            <Canvas x:Name="graphCanvas"
                    ClipToBounds="True"
                    MouseWheel="GraphCanvas_MouseWheel"
                    MouseLeftButtonDown="GraphCanvas_MouseLeftButtonDown"
                    MouseMove="GraphCanvas_MouseMove"
                    MouseLeftButtonUp="GraphCanvas_MouseLeftButtonUp"
                    MouseRightButtonDown="GraphCanvas_MouseRightButtonDown">
                <Canvas.RenderTransform>
                    <TransformGroup>
                        <ScaleTransform x:Name="canvasScaleTransform" ScaleX="1" ScaleY="1"/>
                        <TranslateTransform x:Name="canvasTranslateTransform" X="0" Y="0"/>
                    </TransformGroup>
                </Canvas.RenderTransform>
                
            </Canvas>
        </Border>

        <!-- RIGHT PANEL: Controls -->
        <Border Grid.Column="2" Background="#F5F5F5" Padding="12" BorderBrush="#CCCCCC" BorderThickness="1,0,0,0">
            <ScrollViewer VerticalScrollBarVisibility="Auto">
                <StackPanel>
                    <TextBlock Text="KONTROL PANELÄ°" FontWeight="Bold" FontSize="14" Margin="0,0,0,15"/>
                    
                    <GroupBox Header="HÄ±zlÄ± Arama" Margin="0,5">
                        <StackPanel Margin="5">
                            <TextBlock Text="Makale ID / Metin:" Margin="0,0,0,4"/>
                            <TextBox x:Name="txtSearch" Padding="4" TextChanged="TxtSearch_TextChanged"/>
                        </StackPanel>
                    </GroupBox>

                    <GroupBox Header="Veri YÃ¼kleme" Margin="0,8">
                        <StackPanel Margin="5">
                            <Button x:Name="btnLoadJson" Content="JSON DosyasÄ± SeÃ§" 
                                    Click="BtnLoadJson_Click" Padding="6" Margin="0,5"/>
                            <TextBlock x:Name="txtJsonStatus" Text="Dosya bekleniyor..." 
                                       TextWrapping="Wrap" Foreground="Gray" FontSize="11" Margin="0,4"/>
                        </StackPanel>
                    </GroupBox>
                    
                    <GroupBox Header="Grafik KeÅŸfi" Margin="0,8">
                        <StackPanel Margin="5">
                            <TextBlock Text="Makale ID Girin:" Margin="0,0,0,4"/>
                            <TextBox x:Name="txtArticleId" Padding="4"/>
                            <Button x:Name="btnExpand" Content="GrafiÄŸi GeniÅŸlet" 
                                    Click="BtnExpand_Click" Padding="6" Margin="0,8"
                                    IsEnabled="False"/>
                            <TextBlock Text="* Grafikteki bir dÃ¼ÄŸÃ¼me de tÄ±klayabilirsiniz" 
                                       FontStyle="Italic" FontSize="10" Foreground="Gray"/>
                        </StackPanel>
                    </GroupBox>
                    
                    <GroupBox Header="Algoritmalar" Margin="0,8">
                        <StackPanel Margin="5">
                            <Button x:Name="btnBetweenness" Content="Betweenness Hesapla" 
                                    Click="BtnBetweenness_Click" Padding="6" Margin="0,5"
                                    IsEnabled="False"/>
                            
                            <Separator Margin="0,12"/>
                            
                            <TextBlock Text="K deÄŸeri:" Margin="0,0,0,4"/>
                            <TextBox x:Name="txtKValue" Text="5" Padding="4"/>
                            <Button x:Name="btnKCore" Content="K-Core Analizi Yap" 
                                    Click="BtnKCore_Click" Padding="6" Margin="0,8"
                                    IsEnabled="False"/>
                        </StackPanel>
                    </GroupBox>
                    
                    <GroupBox Header="GÃ¶rÃ¼nÃ¼m KontrolÃ¼" Margin="0,8">
                        <StackPanel Margin="5">
                            <Button x:Name="btnReset" Content="SÄ±fÄ±rla" 
                                    Click="BtnReset_Click" Padding="6" Margin="0,5"
                                    Background="#FFE8E8" IsEnabled="False"/>
                            <TextBlock Text="KÄ±sayol: ESC" 
                                       FontStyle="Italic" FontSize="10" Foreground="Gray" HorizontalAlignment="Center"/>
                        </StackPanel>
                    </GroupBox>
                    
                    <GroupBox Header="SonuÃ§lar" Margin="0,8,0,5">
                        <StackPanel Margin="5">
                            <ScrollViewer MaxHeight="180" VerticalScrollBarVisibility="Auto">
                                <TextBlock x:Name="txtMetricResults" Text="SonuÃ§lar burada gÃ¶rÃ¼necek." 
                                           TextWrapping="Wrap" FontFamily="Consolas" FontSize="11"/>
                            </ScrollViewer>
                        </StackPanel>
                    </GroupBox>
                </StackPanel>
            </ScrollViewer>
        </Border>
    </Grid>
</Window>

---------------------------------------
 MainWindow.xaml.cs
--------------------------------------- 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using Microsoft.Win32;
using ArticleGraphProject.Models;
using ArticleGraphProject.Services;
using ArticleGraphProject.Algorithms;
using System.Threading.Tasks;

namespace ArticleGraphProject
{
    public partial class MainWindow : Window
    {
        public enum RenderMode { Global, Expanded }
        private RenderMode _renderMode = RenderMode.Global;
        
        private Graph? _globalGraph;
        private Graph? _expandedGraph;
        
        private List<Article> _articles = new List<Article>();
        
        // Services and algorithm classes
        private JsonParser _jsonParser;
        private GraphBuilder _graphBuilder;
        private GraphExpander? _graphExpander;
        private BetweennessCalculator _betweennessCalculator;
        private KCoreDecomposer _kCoreDecomposer;


        // Node positions
        private Dictionary<string, Point> _globalNodePositions = new Dictionary<string, Point>();
        private Dictionary<string, Point> _expandedNodePositions = new Dictionary<string, Point>();
        
        // Visual element references
        private Dictionary<string, Ellipse> _nodeVisuals = new Dictionary<string, Ellipse>();
        private HashSet<string> _kCoreNodes = new HashSet<string>();
        private Dictionary<string, double> _betweennessScores = new Dictionary<string, double>();
        
        // Edge visual list
        private List<Line> _edgeVisuals = new List<Line>();
        
        // Node-edge mappings
        private Dictionary<string, List<Line>> _nodeToEdgeVisuals = new Dictionary<string, List<Line>>();
        
        // Active highlight list
        private List<Line> _activeHighlightLines = new List<Line>();
        
        // Visible node set
        private HashSet<string> _visibleNodeSet = new HashSet<string>();
        
        // Camera control
        private Point _lastMousePos;
        private bool _isPanning = false;
        
        private string? _lastSelectedArticleId = null;
        private int _visibleNodeCount = 200;
        
        // UI state
        private string _searchText = string.Empty;
        private int _filesLoadedCount = 0;
        private ToolTip? _activeTooltip;

        public MainWindow()
        {
            InitializeComponent();
            _jsonParser = new JsonParser();
            _graphBuilder = new GraphBuilder();
            _betweennessCalculator = new BetweennessCalculator();
            _kCoreDecomposer = new KCoreDecomposer();

        }

        #region Data Loading

        private void BtnLoadJson_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new OpenFileDialog
            {
                Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                Title = "Makale JSON DosyasÄ±nÄ± SeÃ§"
            };

            if (openFileDialog.ShowDialog() == true)
            {
                try
                {
                    // Load JSON data
                    _articles = _jsonParser.LoadArticles(openFileDialog.FileName);
                    
                    // Create global graph
                    _globalGraph = _graphBuilder.BuildGlobalGraph(_articles);
                    
                    // Reset expanded graph
                    _expandedGraph = null;
                    ResetToGlobalGraph();
                    
                    _graphExpander = new GraphExpander(_globalGraph);
                    
                    // Update status
                    _filesLoadedCount++;
                    string fileName = System.IO.Path.GetFileName(openFileDialog.FileName);
                    
                    txtJsonStatus.Text = $"âœ” Dosya #{_filesLoadedCount}: '{fileName}'\n" + 
                                         $"   {_articles.Count:N0} makale baÅŸarÄ±yla yÃ¼klendi.";
                    txtJsonStatus.Foreground = Brushes.DarkGreen;
                    txtJsonStatus.FontWeight = FontWeights.Bold;

                    UpdateStatistics();
                    
                    // Enable buttons
                    btnExpand.IsEnabled = true;
                    btnBetweenness.IsEnabled = true;
                    btnKCore.IsEnabled = true;
                    btnReset.IsEnabled = true;
                    
                    // Slider settings
                    sliderVisibleNodes.Maximum = _articles.Count;
                    sliderVisibleNodes.Value = Math.Min(200, _articles.Count);
                    
                    Render();
                }
                catch (Exception ex)
                {
                    txtJsonStatus.Text = "âŒ YÃ¼kleme HatasÄ±";
                    txtJsonStatus.Foreground = Brushes.Red;
                    MessageBox.Show($"JSON yÃ¼kleme hatasÄ±: {ex.Message}", "Hata", 
                        MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        #endregion

        #region Statistics Update

        private void UpdateStatistics()
        {
            if (_globalGraph == null) return;
            
            // Global statistics
            txtTotalNodes.Text = _globalGraph.Nodes.Count.ToString();
            txtBlackEdges.Text = _globalGraph.GetBlackEdgeCount().ToString();

            // Most cited
            var mostCited = _globalGraph.Nodes.Values
                .OrderByDescending(n => _globalGraph.GetIncomingBlackEdgeCount(n.NumericId))
                .FirstOrDefault();
            
            if (mostCited != null)
            {
                txtMostCited.Text = mostCited.NumericId;
                txtMostCitedCount.Text = _globalGraph.GetIncomingBlackEdgeCount(mostCited.NumericId).ToString();
            }

            // Most referencing
            var mostReferencing = _globalGraph.Nodes.Values
                .OrderByDescending(n => _globalGraph.GetOutgoingBlackEdgeCount(n.NumericId))
                .FirstOrDefault();
            
            if (mostReferencing != null)
            {
                txtMostReferencing.Text = mostReferencing.NumericId;
                txtMostReferencingCount.Text = _globalGraph.GetOutgoingBlackEdgeCount(mostReferencing.NumericId).ToString();
            }

            // Subgraph statistics
            if (_expandedGraph != null)
            {
                txtCurrentNodes.Text = _expandedGraph.Nodes.Count.ToString();
                txtCurrentEdges.Text = _expandedGraph.GetBlackEdgeCount().ToString();
            }
            else
            {
                txtCurrentNodes.Text = "-";
                txtCurrentEdges.Text = "-";
            }
        }

        #endregion

        #region Stage 2 H Index Expansion

        private void BtnExpand_Click(object sender, RoutedEventArgs e)
        {
            string rawInput = txtArticleId.Text;
            string articleId = NormalizeId(rawInput);

            if (string.IsNullOrWhiteSpace(articleId))
            {
                MessageBox.Show("LÃ¼tfen bir Makale ID girin", "GiriÅŸ Gerekli", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (_globalGraph != null && !_globalGraph.Nodes.ContainsKey(articleId))
            {
                 MessageBox.Show($"'{rawInput}' (normalleÅŸtirilmiÅŸ: {articleId}) veri setinde bulunamadi.", "Bulunamadi", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            PerformExpansion(articleId);
        }

        private string NormalizeId(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return string.Empty;
            input = input.Trim().ToUpper();
            // W prefix normalization
            return input.StartsWith("W") ? input : "W" + input;
        }

        private void PerformExpansion(string articleId)
        {
            if (_globalGraph == null || _graphExpander == null) return;

            articleId = NormalizeId(articleId);
            if (!_globalGraph.Nodes.ContainsKey(articleId))
            {
                MessageBox.Show($"'{articleId}' veri setinde bulunamadÄ±", "BulunamadÄ±", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                // Add to existing graph
                if (_expandedGraph == null)
                {
                    _expandedGraph = new Graph();
                }
                
                // H-Index calculation
                var hIndexResult = _graphExpander.ExpandGraph(_expandedGraph, articleId);
                
                if (hIndexResult.HIndex == 0)
                {
                    MessageBox.Show(
                        "Bu makalenin H-indeksi 0 olduÄŸu iÃ§in geniÅŸletilmiyor.",
                        "GeniÅŸletme MÃ¼mkÃ¼n DeÄŸil",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
                    return;
                }

                _lastSelectedArticleId = articleId;
                
                // Clear old highlights
                foreach (var node in _expandedGraph.Nodes.Values) node.State = NodeState.Normal;
                
                // Highlight selected node
                if (_expandedGraph.Nodes.ContainsKey(articleId))
                    _expandedGraph.Nodes[articleId].State = NodeState.Selected;
                
                // Highlight H-Core nodes
                foreach (var coreId in hIndexResult.HCore)
                {
                    if (_expandedGraph.Nodes.ContainsKey(coreId))
                        _expandedGraph.Nodes[coreId].State = NodeState.HCore;
                }
                
                // Update statistics
                txtSelectedArticle.Text = articleId;
                txtHIndex.Text = hIndexResult.HIndex.ToString();
                txtHCoreSize.Text = hIndexResult.HCore.Count.ToString();
                txtHMedian.Text = hIndexResult.HMedian.ToString("F2");
                
                UpdateStatistics();
                _renderMode = RenderMode.Expanded;
                
                // Reset camera
                canvasTranslateTransform.X = 0;
                canvasTranslateTransform.Y = 0;
                canvasScaleTransform.ScaleX = 1;
                canvasScaleTransform.ScaleY = 1;

                Render();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"GeniÅŸletme hatasÄ±: {ex.Message}", "Hata", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        #region Stage 3 Metrics

        private async void BtnBetweenness_Click(object sender, RoutedEventArgs e)
        {
            if (_renderMode != RenderMode.Expanded || _expandedGraph == null || _expandedGraph.Nodes.Count == 0)
            {
                MessageBox.Show("LÃ¼tfen Ã¶nce bir makale seÃ§ip grafiÄŸi geniÅŸletin.", 
                    "Grafik BoÅŸ", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                // Temporarily disable UI
                btnBetweenness.IsEnabled = false;
                btnExpand.IsEnabled = false;
                btnReset.IsEnabled = false;
                btnKCore.IsEnabled = false;
                txtMetricResults.Text = "HesaplanÄ±yor... (bÃ¼yÃ¼k aÄŸlarda biraz sÃ¼rebilir)";

                var betweennessDict = await Task.Run(() => 
                {
                    return _betweennessCalculator.CalculateBetweenness(_expandedGraph);
                });
                
                // Store results
                _betweennessScores = betweennessDict;
                
                var betweenness = _betweennessCalculator.GetSortedBetweenness(betweennessDict);

                var results = "Betweenness Centrality Ä°lk 20:\n\n";
                foreach (var item in betweenness.Take(20))
                {
                    results += $"{item.NodeId}: {item.Betweenness:F2}\n";
                }
                
                txtMetricResults.Text = results;
                
                // Redraw for visualization
                Render();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Hesaplama hatasÄ±: {ex.Message}", "Hata", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                txtMetricResults.Text = "Hata oluÅŸtu.";
            }
            finally
            {
                // Re-enable UI
                btnBetweenness.IsEnabled = true;
                btnExpand.IsEnabled = true;
                btnReset.IsEnabled = true;
                btnKCore.IsEnabled = true;
                UpdateStatistics();
                if (_renderMode == RenderMode.Expanded) Render();
            }
        }

        private void BtnKCore_Click(object sender, RoutedEventArgs e)
        {
            if (_renderMode != RenderMode.Expanded || _expandedGraph == null || _expandedGraph.Nodes.Count == 0)
            {
                MessageBox.Show("LÃ¼tfen Ã¶nce bir makale seÃ§ip grafiÄŸi geniÅŸletin.", 
                    "Grafik BoÅŸ", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (!int.TryParse(txtKValue.Text, out int k) || k < 1)
            {
                MessageBox.Show("LÃ¼tfen geÃ§erli bir K deÄŸeri girin (pozitif tam sayÄ±).", "GeÃ§ersiz GiriÅŸ", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                // Convert to undirected graph
                var undirected = _expandedGraph.ToUndirected();
                _kCoreNodes = _kCoreDecomposer.FindKCore(undirected, k);

                // Update node states
                foreach (var node in _expandedGraph.Nodes.Values)
                {
                    if (_kCoreNodes.Contains(node.NumericId))
                    {
                        node.State = NodeState.KCore;
                    }
                    else if (node.NumericId != _lastSelectedArticleId)
                    {
                        node.State = NodeState.Normal;
                    }
                }
                
                txtMetricResults.Text = $"K-Core (K={k}):\n\n" +
                    $"DÃ¼ÄŸÃ¼m sayÄ±sÄ±: {_kCoreNodes.Count}\n\n" +
                    string.Join(", ", _kCoreNodes.Take(50));
                
                if (_renderMode == RenderMode.Expanded) Render();
                UpdateStatistics();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"K-Core hatasÄ±: {ex.Message}", "Hata", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        #region Reset

        private void BtnReset_Click(object sender, RoutedEventArgs e)
        {
            ResetToGlobalGraph();
        }

        private void TxtSearch_TextChanged(object sender, TextChangedEventArgs e)
        {
            _searchText = txtSearch.Text.Trim();
            if (_nodeVisuals == null) return;

            // Apply search filter
            foreach (var kvp in _nodeVisuals)
            {
                var nodeId = kvp.Key;
                var ellipse = kvp.Value;
                bool isMatch = string.IsNullOrEmpty(_searchText) ||
                               nodeId.Contains(_searchText, StringComparison.OrdinalIgnoreCase);
                ellipse.Opacity = isMatch ? 1.0 : 0.1;
            }
        }

        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Escape)
            {
                ResetToGlobalGraph();
            }
            else if (e.Key == Key.F && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)
            {
                txtSearch.Focus();
                e.Handled = true;
            }
            else if (e.Key == Key.R && (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control)
            {
                ResetToGlobalGraph();
                e.Handled = true;
            }
        }

        private void ResetToGlobalGraph()
        {
            if (_globalGraph == null) return;
            
            _globalGraph.ClearCache();
            _expandedGraph = null;
            _expandedNodePositions.Clear();
            _renderMode = RenderMode.Global;
            _kCoreNodes.Clear();
            _betweennessScores.Clear();
            
            _lastSelectedArticleId = null;
            // Reset UI labels
            txtSelectedArticle.Text = "-";
            txtHIndex.Text = "-";
            txtHCoreSize.Text = "-";
            txtHMedian.Text = "-";
            txtMetricResults.Text = "HenÃ¼z metrik hesaplanmadÄ±";
            
            UpdateStatistics();
            
            // Reset zoom and pan
            canvasScaleTransform.ScaleX = 1;
            canvasScaleTransform.ScaleY = 1;
            canvasTranslateTransform.X = 0;
            canvasTranslateTransform.Y = 0;
            
            Render();
        }

        #endregion

        #region Rendering Logic

        private void Render()
        {
            graphCanvas.Children.Clear();
            _nodeVisuals.Clear();
            _edgeVisuals.Clear();
            _nodeToEdgeVisuals.Clear();
            _activeHighlightLines.Clear();

            // Return to global mode if expanded graph is empty
            if (_renderMode == RenderMode.Expanded && (_expandedGraph == null || _expandedGraph.Nodes.Count == 0))
            {
                _renderMode = RenderMode.Global;
            }

            switch (_renderMode)
            {
                case RenderMode.Expanded:
                    RenderExpandedGraph();
                    break;
                case RenderMode.Global:
                default:
                    if (_globalGraph != null) RenderGlobalGraph();
                    break;
            }
        }

        private void RenderGlobalGraph()
        {
            if (_globalGraph == null) return;

            if (_globalNodePositions.Count == 0) CalculateGlobalLayout();

            _visibleNodeSet.Clear();
            // Select nodes by importance
            var importantNodes = _globalGraph.Nodes.Values
                .Select(n => new
                {
                    Node = n,
                    Importance = _globalGraph.GetIncomingBlackEdgeCount(n.NumericId) + 
                                 _globalGraph.GetOutgoingBlackEdgeCount(n.NumericId)
                })
                .OrderByDescending(x => x.Importance)
                .Take(_visibleNodeCount)
                .Select(x => x.Node.NumericId);
                
            foreach (var id in importantNodes) _visibleNodeSet.Add(id);

            DrawGlobalEdges();
            DrawGlobalNodes();
        }

        private void CalculateGlobalLayout()
        {
            if (_globalGraph == null) return;
            _globalNodePositions.Clear();

            double centerX = graphCanvas.ActualWidth / 2;
            double centerY = graphCanvas.ActualHeight / 2;
            
            // Spiral layout calculation
            var sortedNodes = _globalGraph.Nodes.Values
                .OrderByDescending(n => _globalGraph.GetIncomingBlackEdgeCount(n.NumericId) + 
                                      _globalGraph.GetOutgoingBlackEdgeCount(n.NumericId))
                .ToList();

            double angle = 0;
            double radius = 10;
            double radiusStep = 0.5;
            double angleStep = 0.5;
            double minNodeDist = 20;

            if (sortedNodes.Count > 0)
                _globalNodePositions[sortedNodes[0].NumericId] = new Point(centerX, centerY);

            for (int i = 1; i < sortedNodes.Count; i++)
            {
                int attempts = 0;
                bool placed = false;
                while (!placed && attempts < 100)
                {
                    double x = centerX + radius * Math.Cos(angle);
                    double y = centerY + radius * Math.Sin(angle);
                    _globalNodePositions[sortedNodes[i].NumericId] = new Point(x, y);
                    placed = true;
                    
                    angle += angleStep;
                    if (radius > 50) angleStep = Math.Max(0.1, 0.5 * (50 / radius));
                    radius += (minNodeDist / (2 * Math.PI * radius)) * 5;
                    if (radiusStep < 0.1) radiusStep = 0.1;
                    radius += radiusStep;
                }
            }
        }

        private void DrawGlobalEdges()
        {
            if (_globalGraph == null) return;
            
            foreach (var edge in _globalGraph.Edges)
            {
                // Skip edges of invisible nodes
                if (_visibleNodeSet.Count > 0)
                {
                    if (!_visibleNodeSet.Contains(edge.From) || !_visibleNodeSet.Contains(edge.To)) continue;
                }

                if (!_globalNodePositions.ContainsKey(edge.From) || !_globalNodePositions.ContainsKey(edge.To)) continue;

                var fromPos = _globalNodePositions[edge.From];
                var toPos = _globalNodePositions[edge.To];

                var line = new Line
                {
                    X1 = fromPos.X, Y1 = fromPos.Y,
                    X2 = toPos.X, Y2 = toPos.Y
                };

                if (edge.EdgeType == EdgeType.Black)
                {
                    line.Stroke = Brushes.Black;
                    line.StrokeThickness = 1.2;
                    line.Opacity = 0.6;
                }
                else
                {
                    // Green edge style
                    line.Stroke = Brushes.LightGreen;
                    line.StrokeThickness = 0.8;
                    line.Opacity = 0.08;
                    line.StrokeDashArray = new DoubleCollection { 2, 2 };
                }

                line.Tag = edge;
                graphCanvas.Children.Add(line);
                _edgeVisuals.Add(line);
                
                // Register edge visuals
                RegisterEdgeVisual(edge.From, line);
                RegisterEdgeVisual(edge.To, line);
            }
        }

        private void DrawGlobalNodes()
        {
            if (_globalGraph == null) return;
            
            foreach (var node in _globalGraph.Nodes.Values)
            {
                if (_visibleNodeSet.Count > 0 && !_visibleNodeSet.Contains(node.NumericId)) continue;
                if (!_globalNodePositions.ContainsKey(node.NumericId)) continue;

                var pos = _globalNodePositions[node.NumericId];
                var ellipse = new Ellipse
                {
                    Width = 3, Height = 3,
                    Fill = new SolidColorBrush(Color.FromRgb(180, 180, 200))
                };
                
                Canvas.SetLeft(ellipse, pos.X - 1.5);
                Canvas.SetTop(ellipse, pos.Y - 1.5);

                // Set opacity according to search filter
                if (!string.IsNullOrEmpty(_searchText) && 
                    !node.NumericId.Contains(_searchText, StringComparison.OrdinalIgnoreCase))
                {
                    ellipse.Opacity = 0.3;
                }
                else
                {
                    ellipse.Opacity = 1.0;
                }

                _nodeVisuals[node.NumericId] = ellipse;
                graphCanvas.Children.Add(ellipse);

                // Click events
                ellipse.MouseLeftButtonDown += (s, e) =>
                {
                    e.Handled = true;
                    if (Keyboard.Modifiers == ModifierKeys.Control) HandlePathSelection(node.NumericId);
                    else PerformExpansion(node.NumericId);
                };
                
                // Mouse interaction events
                ellipse.MouseEnter += (s, e) => { ShowNodeTooltip(node, ellipse); HighlightConnectedEdges(node.NumericId); };
                ellipse.MouseLeave += (s, e) => { HideNodeTooltip(); ResetEdgeHighlight(); };
            }
        }

        private void RenderExpandedGraph()
        {
            if (_expandedGraph == null) return;
            
            _visibleNodeSet.Clear();
            foreach (var nodeId in _expandedGraph.Nodes.Keys) _visibleNodeSet.Add(nodeId);

            CalculateExpandedLayout();
            DrawExpandedEdges();
            DrawExpandedNodes();
        }

        private void CalculateExpandedLayout()
        {
            if (_expandedGraph == null) return;
            
            double centerX = graphCanvas.ActualWidth / 2;
            double centerY = graphCanvas.ActualHeight / 2;
            Point centerPoint = new Point(centerX, centerY);

            if (_expandedNodePositions.Count == 0 && _lastSelectedArticleId != null)
                _expandedNodePositions[_lastSelectedArticleId] = centerPoint;

            var newNodes = _expandedGraph.Nodes.Keys
                .Where(id => !_expandedNodePositions.ContainsKey(id))
                .ToList();
            
            if (newNodes.Count == 0) return;

            // Place new nodes around the center
            Point sourcePos = centerPoint;
            if (_lastSelectedArticleId != null && _expandedNodePositions.ContainsKey(_lastSelectedArticleId))
                sourcePos = _expandedNodePositions[_lastSelectedArticleId];

            double radius = 150;
            // Adjust radius based on node count
            if (newNodes.Count > 20) radius += (newNodes.Count - 20) * 2;

            for (int i = 0; i < newNodes.Count; i++)
            {
                double angle = 2 * Math.PI * i / newNodes.Count;
                // Circular layout
                angle += _expandedNodePositions.Count * 0.1;
                double x = sourcePos.X + radius * Math.Cos(angle);
                double y = sourcePos.Y + radius * Math.Sin(angle);
                _expandedNodePositions[newNodes[i]] = new Point(x, y);
            }
        }

        private void DrawExpandedEdges()
        {
            if (_expandedGraph == null) return;
            
            foreach (var edge in _expandedGraph.Edges)
            {
                if (!_expandedNodePositions.ContainsKey(edge.From) || !_expandedNodePositions.ContainsKey(edge.To)) continue;

                var fromPos = _expandedNodePositions[edge.From];
                var toPos = _expandedNodePositions[edge.To];

                var line = new Line
                {
                    X1 = fromPos.X, Y1 = fromPos.Y,
                    X2 = toPos.X, Y2 = toPos.Y
                };

                if (edge.EdgeType == EdgeType.Black)
                {
                    // K-Core edge check
                    bool isKCoreEdge = _kCoreNodes.Contains(edge.From) && _kCoreNodes.Contains(edge.To);
                    
                    if (isKCoreEdge)
                    {
                        line.Stroke = Brushes.DarkMagenta;
                        line.StrokeThickness = 2.5;
                        line.Opacity = 0.9;
                    }
                    else
                    {
                        line.Stroke = Brushes.Black;
                        line.StrokeThickness = 1.5;
                        line.Opacity = 0.7;
                    }
                }
                else
                {
                    // Green edge style
                    line.Stroke = Brushes.LightGreen;
                    line.StrokeThickness = 0.8;
                    line.Opacity = 0.08;
                    line.StrokeDashArray = new DoubleCollection { 2, 2 };
                }

                line.Tag = edge;
                graphCanvas.Children.Add(line);
                _edgeVisuals.Add(line);
                
                // Register edge visuals
                RegisterEdgeVisual(edge.From, line);
                RegisterEdgeVisual(edge.To, line);
            }
        }

        private void RegisterEdgeVisual(string nodeId, Line line)
        {
            if (!_nodeToEdgeVisuals.ContainsKey(nodeId))
            {
                _nodeToEdgeVisuals[nodeId] = new List<Line>();
            }
            _nodeToEdgeVisuals[nodeId].Add(line);
        }

        private void DrawExpandedNodes()
        {
            if (_expandedGraph == null) return;
            
            foreach (var node in _expandedGraph.Nodes.Values)
            {
                if (!_expandedNodePositions.ContainsKey(node.NumericId)) continue;
                var pos = _expandedNodePositions[node.NumericId];

                // Sizing by citation count
                int citations = _globalGraph != null ? _globalGraph.GetIncomingBlackEdgeCount(node.NumericId) : 0;
                double nodeSize = Math.Max(20, 30 + Math.Log(citations + 1) * 4.0);
                
                // Coloring by node state
                Brush nodeFill = Brushes.LightGray;
                Brush nodeStroke = Brushes.DimGray;
                double strokeThickness = 1.0;
                
                if (node.State == NodeState.KCore)
                {
                    // K-Core nodes: Purple with thick border
                    nodeFill = Brushes.MediumPurple;
                    nodeStroke = Brushes.DarkMagenta;
                    strokeThickness = 3.0;
                }
                else if (node.State == NodeState.Selected)
                {
                    // Selected node: Salmon/Red
                    nodeFill = Brushes.Salmon;
                    nodeStroke = Brushes.DarkRed;
                    strokeThickness = 2.5;
                }
                else if (node.State == NodeState.HCore)
                {
                    // H-Core nodes: Gold
                    nodeFill = Brushes.Gold;
                    nodeStroke = Brushes.DarkGoldenrod;
                    strokeThickness = 2.0;
                }
                else if (citations > 10)
                {
                    // High citation normal nodes: Light blue
                    nodeFill = Brushes.LightSkyBlue;
                }

                var ellipse = new Ellipse
                {
                    Width = nodeSize, 
                    Height = nodeSize,
                    Fill = nodeFill, 
                    Stroke = nodeStroke, 
                    StrokeThickness = strokeThickness
                };

                // Search filter opacity
                if (!string.IsNullOrEmpty(_searchText) && 
                    !node.NumericId.Contains(_searchText, StringComparison.OrdinalIgnoreCase))
                {
                    ellipse.Opacity = 0.3;
                }
                else
                {
                    ellipse.Opacity = 1.0;
                }

                Canvas.SetLeft(ellipse, pos.X - nodeSize / 2);
                Canvas.SetTop(ellipse, pos.Y - nodeSize / 2);

                _nodeVisuals[node.NumericId] = ellipse;
                graphCanvas.Children.Add(ellipse);

                // Labels
                var countLabel = new TextBlock
                {
                    Text = citations.ToString(),
                    FontSize = Math.Max(10, nodeSize / 2.5),
                    FontWeight = FontWeights.Bold,
                    Foreground = Brushes.Black,
                    IsHitTestVisible = false
                };
                
                countLabel.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(countLabel, pos.X - countLabel.DesiredSize.Width / 2);
                Canvas.SetTop(countLabel, pos.Y - countLabel.DesiredSize.Height / 2);
                
                if (ellipse.Opacity > 0.5) graphCanvas.Children.Add(countLabel);

                var detailsLabel = new TextBlock
                {
                    Text = $"{node.NumericId}\n{node.AuthorInitials}",
                    FontSize = 10, Foreground = Brushes.Black,
                    TextAlignment = TextAlignment.Center, IsHitTestVisible = false
                };
                
                detailsLabel.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                Canvas.SetLeft(detailsLabel, pos.X - detailsLabel.DesiredSize.Width / 2);
                Canvas.SetTop(detailsLabel, pos.Y + nodeSize / 2 + 2);

                if (ellipse.Opacity > 0.5) graphCanvas.Children.Add(detailsLabel);

                // Betweenness score display
                if (_betweennessScores.ContainsKey(node.NumericId))
                {
                    var betweennessLabel = new TextBlock
                    {
                        Text = $"BC: {_betweennessScores[node.NumericId]:F1}",
                        FontSize = 9,
                        FontWeight = FontWeights.Bold,
                        Foreground = Brushes.DarkBlue,
                        Background = new SolidColorBrush(Color.FromArgb(180, 255, 255, 200)), // Semi-transparent yellow
                        Padding = new Thickness(2),
                        IsHitTestVisible = false
                    };
                    
                    betweennessLabel.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
                    Canvas.SetLeft(betweennessLabel, pos.X - betweennessLabel.DesiredSize.Width / 2);
                    Canvas.SetTop(betweennessLabel, pos.Y + nodeSize / 2 + 18);
                    
                    if (ellipse.Opacity > 0.5) graphCanvas.Children.Add(betweennessLabel);
                }

                // Event handlers
                ellipse.MouseEnter += (s, e) => { ShowNodeTooltip(node, ellipse); HighlightConnectedEdges(node.NumericId); };
                ellipse.MouseLeave += (s, e) => { HideNodeTooltip(); ResetEdgeHighlight(); };
                ellipse.MouseLeftButtonDown += (s, e) => { e.Handled = true; PerformExpansion(node.NumericId); };
            }
        }

        #endregion

        #region Interaction Helpers

        private void HighlightConnectedEdges(string nodeId)
        {
            // O(1) dictionary lookup
            if (_nodeToEdgeVisuals.TryGetValue(nodeId, out var connectedLines))
            {
                foreach (var line in connectedLines)
                {
                    if (line.Tag is GraphEdge edge)
                    {
                        // Apply highlight
                        line.Opacity = 1.0;
                        if (edge.From == nodeId)
                        {
                            line.Stroke = Brushes.Orange;
                            Panel.SetZIndex(line, 50);
                        }
                        else if (edge.To == nodeId)
                        {
                            line.Stroke = Brushes.DeepSkyBlue;
                            Panel.SetZIndex(line, 50);
                        }
                        
                        _activeHighlightLines.Add(line);
                    }
                }
            }
        }

        private void ResetEdgeHighlight()
        {
            // Reset only highlighted edges
            foreach (var line in _activeHighlightLines)
            {
                if (line.Tag is GraphEdge edge)
                {
                    if (edge.EdgeType == EdgeType.Black)
                    {
                        line.Stroke = Brushes.Black;
                        line.Opacity = (_renderMode == RenderMode.Global) ? 0.6 : 0.75;
                    }
                    else
                    {
                        // Green edge default style
                        line.Stroke = Brushes.LightGreen;
                        line.Opacity = 0.08;
                    }
                    Panel.SetZIndex(line, 0);
                }
            }
            _activeHighlightLines.Clear();
        }

        private void ShowNodeTooltip(GraphNode node, Ellipse ellipse)
        {
            // Close previous tooltip
            HideNodeTooltip();

            string tooltipText = $"ID: {node.NumericId}\n" +
                $"BaÅŸlÄ±k: {node.ArticleData.Title}\n" +
                $"Yazarlar: {(node.ArticleData.Authors.Any() ? string.Join(", ", node.ArticleData.Authors) : "Yok")}\n" +
                $"YÄ±l: {node.ArticleData.Year}\n" +
                $"AtÄ±f (Gelen): {_globalGraph?.GetIncomingBlackEdgeCount(node.NumericId) ?? 0}";
                
            _activeTooltip = new ToolTip
            {
                Content = new TextBlock { Text = tooltipText, MaxWidth = 300, TextWrapping = TextWrapping.Wrap },
                PlacementTarget = ellipse,
                Placement = System.Windows.Controls.Primitives.PlacementMode.Right,
                IsOpen = true
            };
        }
        
        private void HideNodeTooltip() 
        { 
            if (_activeTooltip != null)
            {
                _activeTooltip.IsOpen = false;
                _activeTooltip = null;
            }
        }

        private void SliderVisibleNodes_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            _visibleNodeCount = (int)e.NewValue;
            if (txtVisibleNodesLabel != null) txtVisibleNodesLabel.Text = $"GÃ¶rÃ¼nen DÃ¼ÄŸÃ¼m: {_visibleNodeCount}";
            // Set slider maximum value
            if (_globalGraph != null && sliderVisibleNodes != null) sliderVisibleNodes.Maximum = _globalGraph.Nodes.Count;
            if (_renderMode == RenderMode.Global && _globalGraph != null) Render();
        }

        private void GraphCanvas_MouseWheel(object sender, MouseWheelEventArgs e)
        {
            double zoomFactor = e.Delta > 0 ? 1.1 : 0.9;
            Point mousePos = e.GetPosition(graphCanvas);
            double newScaleX = canvasScaleTransform.ScaleX * zoomFactor;
            double newScaleY = canvasScaleTransform.ScaleY * zoomFactor;

            // Zoom limits
            if (newScaleX < 0.1 || newScaleX > 5.0) return;

            // Zoom towards mouse position
            canvasTranslateTransform.X = mousePos.X - (mousePos.X - canvasTranslateTransform.X) * zoomFactor;
            canvasTranslateTransform.Y = mousePos.Y - (mousePos.Y - canvasTranslateTransform.Y) * zoomFactor;
            canvasScaleTransform.ScaleX = newScaleX;
            canvasScaleTransform.ScaleY = newScaleY;
            e.Handled = true;
        }

        private void GraphCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            // Start panning
            if (e.OriginalSource == graphCanvas && e.LeftButton == MouseButtonState.Pressed && e.RightButton == MouseButtonState.Pressed)
            {
                _isPanning = true;
                _lastMousePos = e.GetPosition(this);
                graphCanvas.CaptureMouse();
                graphCanvas.Cursor = Cursors.Hand;
                e.Handled = true;
            }
        }

        private void GraphCanvas_MouseMove(object sender, MouseEventArgs e)
        {
            if (_isPanning)
            {
                Point currentPos = e.GetPosition(this);
                Vector delta = currentPos - _lastMousePos;
                canvasTranslateTransform.X += delta.X;
                canvasTranslateTransform.Y += delta.Y;
                _lastMousePos = currentPos;
            }
        }

        private void GraphCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (_isPanning)
            {
                _isPanning = false;
                graphCanvas.ReleaseMouseCapture();
                graphCanvas.Cursor = Cursors.Arrow;
            }
        }
        
        private void GraphCanvas_MouseRightButtonDown(object sender, MouseButtonEventArgs e) { e.Handled = true; }

        private void HandlePathSelection(string nodeId) { }
        
        #endregion
    }
}



